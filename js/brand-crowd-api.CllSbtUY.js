var b=Object.defineProperty;var C=(r,t,e)=>t in r?b(r,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[t]=e;var m=(r,t,e)=>C(r,typeof t!="symbol"?t+"":t,e);import{V as A,r as p,W as x,X as $,Y as T,$ as B,w as k,u as O,C as S,z as R,f as U,k as E}from"./entry.DvYAX4a8.js";import{c as M}from"./browser.DKkg-gxU.js";const z=r=>r==="defer"||r===!1;function V(...r){var h;const t=typeof r[r.length-1]=="string"?r.pop():void 0;typeof r[0]!="string"&&r.unshift(t);let[e,a,s={}]=r;if(typeof e!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof a!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const n=O(),w=a,D=()=>null,v=()=>n.isHydrating?n.payload.data[e]:n.static.data[e];s.server=s.server??!0,s.default=s.default??D,s.getCachedData=s.getCachedData??v,s.lazy=s.lazy??!1,s.immediate=s.immediate??!0,s.deep=s.deep??A.deep,s.dedupe=s.dedupe??"cancel";const f=()=>![null,void 0].includes(s.getCachedData(e));if(!n._asyncData[e]||!s.immediate){(h=n.payload._errors)[e]??(h[e]=null);const c=s.deep?p:x;n._asyncData[e]={data:c(s.getCachedData(e)??s.default()),pending:p(!f()),error:$(n.payload._errors,e),status:p("idle")}}const o={...n._asyncData[e]};o.refresh=o.execute=(c={})=>{if(n._asyncDataPromises[e]){if(z(c.dedupe??s.dedupe))return n._asyncDataPromises[e];n._asyncDataPromises[e].cancelled=!0}if((c._initial||n.isHydrating&&c._initial!==!1)&&f())return Promise.resolve(s.getCachedData(e));o.pending.value=!0,o.status.value="pending";const d=new Promise((i,u)=>{try{i(w(n))}catch(_){u(_)}}).then(i=>{if(d.cancelled)return n._asyncDataPromises[e];let u=i;s.transform&&(u=s.transform(i)),s.pick&&(u=H(u,s.pick)),n.payload.data[e]=u,o.data.value=u,o.error.value=null,o.status.value="success"}).catch(i=>{if(d.cancelled)return n._asyncDataPromises[e];o.error.value=S(i),o.data.value=R(s.default()),o.status.value="error"}).finally(()=>{d.cancelled||(o.pending.value=!1,delete n._asyncDataPromises[e])});return n._asyncDataPromises[e]=d,n._asyncDataPromises[e]};const y=()=>o.refresh({_initial:!0}),P=s.server!==!1&&n.payload.serverRendered;{const c=U();if(c&&!c._nuxtOnBeforeMountCbs){c._nuxtOnBeforeMountCbs=[];const i=c._nuxtOnBeforeMountCbs;c&&(T(()=>{i.forEach(u=>{u()}),i.splice(0,i.length)}),B(()=>i.splice(0,i.length)))}P&&n.isHydrating&&(o.error.value||f())?(o.pending.value=!1,o.status.value=o.error.value?"error":"success"):c&&(n.payload.serverRendered&&n.isHydrating||s.lazy)&&s.immediate?c._nuxtOnBeforeMountCbs.push(y):s.immediate&&y(),s.watch&&k(s.watch,()=>o.refresh());const d=n.hook("app:data:refresh",async i=>{(!i||i.includes(e))&&await o.refresh()});c&&B(d)}const g=Promise.resolve(n._asyncDataPromises[e]).then(()=>o);return Object.assign(g,o),g}function H(r,t){const e={};for(const a of t)e[a]=r[a];return e}const j="/maker/api/brand-pages",q="/maker/api/brand-sites",F="/maker/api/brand-contacts",l=M.withTag("brand-crowd-api");class I{constructor(t){m(this,"fetchOptions");this.fetchOptions={baseURL:t.brandCrowdBaseUrl,headers:{"content-type":"application/json"},ignoreResponseError:!0,redirect:"manual",timeout:t.apiRequestTimeout}}async getBrandPageBySlugAsync(t){const e=`${j}/${t}`,a=await $fetch.raw(e,this.fetchOptions);if(l.log("getBrandPageBySlugAsync",e,t,a.status,a.statusText),a.status===200)return a._data}async getBrandSiteBySlugAsync(t){const e=`${q}/${t}`,a=await $fetch.raw(e,this.fetchOptions);if(l.log("getBrandSiteBySlugAsync",e,t,a.status,a.statusText),a.status===200)return a._data}async getBrandContactBySlugAsync(t){const e=`${F}/${t}`,a=await $fetch.raw(e,this.fetchOptions);if(l.log("getBrandContactBySlugAsync",e,t,a.status,a.statusText),a.status===200)return a._data}async getBrandPageByBrandPageTokenAsync(t){const e=`maker/api/brand-pages/brand-page-token/${t}`,a=await $fetch.raw(e,this.fetchOptions);if(l.log("getBrandPageByBrandPageTokenAsync",e,t,a.status,a.statusText),a.status===200)return a._data}async getBrandPageByDesignDraftTokenAsync(t){const e=`maker/api/brand-pages/designs/${t}`,a=await $fetch.raw(e,this.fetchOptions);if(l.log("getBrandPageByDesignDraftTokenAsync",e,t,a.status,a.statusText),a.status===200)return a._data}async getBrandPageTemplateByTokenAsync(t){const e=`maker/api/template/${t}`,a=await $fetch.raw(e,this.fetchOptions);if(l.log("getBrandPageTemplateByTokenAsync",e,t,a.status,a.statusText),a.status!==200)throw new Error(`Unable to retrieve Brand Page Template by token '${t}'`);return a._data}}const W=()=>{const{apiRequestTimeout:r,brandCrowdBaseUrl:t,isProduction:e}=E();return new I({apiRequestTimeout:r,brandCrowdBaseUrl:t,isProduction:e})};export{W as a,V as u};
