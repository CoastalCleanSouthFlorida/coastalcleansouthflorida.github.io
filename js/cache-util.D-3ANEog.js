var Ht=Object.defineProperty;var Ct=a=>{throw TypeError(a)};var Pt=(a,e,i)=>e in a?Ht(a,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):a[e]=i;var _=(a,e,i)=>Pt(a,typeof e!="symbol"?e+"":e,i),yt=(a,e,i)=>e.has(a)||Ct("Cannot "+i);var t=(a,e,i)=>(yt(a,e,"read from private field"),i?i.call(a):e.get(a)),p=(a,e,i)=>e.has(a)?Ct("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(a):e.set(a,i),c=(a,e,i,s)=>(yt(a,e,"write to private field"),s?s.call(a,i):e.set(a,i),i),l=(a,e,i)=>(yt(a,e,"access private method"),i);var dt=(a,e,i,s)=>({set _(h){c(a,e,h,i)},get _(){return t(a,e,s)}});const rt=typeof performance=="object"&&performance&&typeof performance.now=="function"?performance:Date,Gt=new Set,At=typeof process=="object"&&process?process:{},It=(a,e,i,s)=>{typeof At.emitWarning=="function"?At.emitWarning(a,e,i,s):console.error(`[${i}] ${e}: ${a}`)};let _t=globalThis.AbortController,Rt=globalThis.AbortSignal;var Lt;if(typeof _t>"u"){Rt=class{constructor(){_(this,"onabort");_(this,"_onabort",[]);_(this,"reason");_(this,"aborted",!1)}addEventListener(s,h){this._onabort.push(h)}},_t=class{constructor(){_(this,"signal",new Rt);e()}abort(s){var h,n;if(!this.signal.aborted){this.signal.reason=s,this.signal.aborted=!0;for(const r of this.signal._onabort)r(s);(n=(h=this.signal).onabort)==null||n.call(h,s)}}};let a=((Lt=At.env)==null?void 0:Lt.LRU_CACHE_IGNORE_AC_WARNING)!=="1";const e=()=>{a&&(a=!1,It("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.","NO_ABORT_CONTROLLER","ENOTSUP",e))}}const kt=a=>!Gt.has(a),K=a=>a&&a===Math.floor(a)&&a>0&&isFinite(a),Mt=a=>K(a)?a<=Math.pow(2,8)?Uint8Array:a<=Math.pow(2,16)?Uint16Array:a<=Math.pow(2,32)?Uint32Array:a<=Number.MAX_SAFE_INTEGER?gt:null:null;class gt extends Array{constructor(e){super(e),this.fill(0)}}var ot;const st=class st{constructor(e,i){_(this,"heap");_(this,"length");if(!t(st,ot))throw new TypeError("instantiate Stack using Stack.create(n)");this.heap=new i(e),this.length=0}static create(e){const i=Mt(e);if(!i)return[];c(st,ot,!0);const s=new st(e,i);return c(st,ot,!1),s}push(e){this.heap[this.length++]=e}pop(){return this.heap[--this.length]}};ot=new WeakMap,p(st,ot,!1);let mt=st;var xt,Ut,N,L,H,P,lt,T,k,m,S,d,R,x,C,E,B,O,V,$,U,q,et,W,o,Ft,nt,X,ct,G,jt,ht,at,ut,Q,tt,Tt,pt,wt,w,Et,ft;const Ot=class Ot{constructor(e){p(this,o);p(this,N);p(this,L);p(this,H);p(this,P);p(this,lt);_(this,"ttl");_(this,"ttlResolution");_(this,"ttlAutopurge");_(this,"updateAgeOnGet");_(this,"updateAgeOnHas");_(this,"allowStale");_(this,"noDisposeOnSet");_(this,"noUpdateTTL");_(this,"maxEntrySize");_(this,"sizeCalculation");_(this,"noDeleteOnFetchRejection");_(this,"noDeleteOnStaleGet");_(this,"allowStaleOnFetchAbort");_(this,"allowStaleOnFetchRejection");_(this,"ignoreFetchAbort");p(this,T);p(this,k);p(this,m);p(this,S);p(this,d);p(this,R);p(this,x);p(this,C);p(this,E);p(this,B);p(this,O);p(this,V);p(this,$);p(this,U);p(this,q);p(this,et);p(this,W);p(this,nt,()=>{});p(this,X,()=>{});p(this,ct,()=>{});p(this,G,()=>!1);p(this,ht,e=>{});p(this,at,(e,i,s)=>{});p(this,ut,(e,i,s,h)=>{if(s||h)throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");return 0});_(this,xt,"LRUCache");const{max:i=0,ttl:s,ttlResolution:h=1,ttlAutopurge:n,updateAgeOnGet:r,updateAgeOnHas:f,allowStale:u,dispose:F,disposeAfter:I,noDisposeOnSet:b,noUpdateTTL:Z,maxSize:M=0,maxEntrySize:Y=0,sizeCalculation:A,fetchMethod:v,noDeleteOnFetchRejection:g,noDeleteOnStaleGet:y,allowStaleOnFetchRejection:D,allowStaleOnFetchAbort:z,ignoreFetchAbort:j}=e;if(i!==0&&!K(i))throw new TypeError("max option must be a nonnegative integer");const it=i?Mt(i):Array;if(!it)throw new Error("invalid max value: "+i);if(c(this,N,i),c(this,L,M),this.maxEntrySize=Y||t(this,L),this.sizeCalculation=A,this.sizeCalculation){if(!t(this,L)&&!this.maxEntrySize)throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");if(typeof this.sizeCalculation!="function")throw new TypeError("sizeCalculation set to non-function")}if(v!==void 0&&typeof v!="function")throw new TypeError("fetchMethod must be a function if specified");if(c(this,lt,v),c(this,et,!!v),c(this,m,new Map),c(this,S,new Array(i).fill(void 0)),c(this,d,new Array(i).fill(void 0)),c(this,R,new it(i)),c(this,x,new it(i)),c(this,C,0),c(this,E,0),c(this,B,mt.create(i)),c(this,T,0),c(this,k,0),typeof F=="function"&&c(this,H,F),typeof I=="function"?(c(this,P,I),c(this,O,[])):(c(this,P,void 0),c(this,O,void 0)),c(this,q,!!t(this,H)),c(this,W,!!t(this,P)),this.noDisposeOnSet=!!b,this.noUpdateTTL=!!Z,this.noDeleteOnFetchRejection=!!g,this.allowStaleOnFetchRejection=!!D,this.allowStaleOnFetchAbort=!!z,this.ignoreFetchAbort=!!j,this.maxEntrySize!==0){if(t(this,L)!==0&&!K(t(this,L)))throw new TypeError("maxSize must be a positive integer if specified");if(!K(this.maxEntrySize))throw new TypeError("maxEntrySize must be a positive integer if specified");l(this,o,jt).call(this)}if(this.allowStale=!!u,this.noDeleteOnStaleGet=!!y,this.updateAgeOnGet=!!r,this.updateAgeOnHas=!!f,this.ttlResolution=K(h)||h===0?h:1,this.ttlAutopurge=!!n,this.ttl=s||0,this.ttl){if(!K(this.ttl))throw new TypeError("ttl must be a positive integer if specified");l(this,o,Ft).call(this)}if(t(this,N)===0&&this.ttl===0&&t(this,L)===0)throw new TypeError("At least one of max, maxSize, or ttl is required");if(!this.ttlAutopurge&&!t(this,N)&&!t(this,L)){const J="LRU_CACHE_UNBOUNDED";kt(J)&&(Gt.add(J),It("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.","UnboundedCacheWarning",J,Ot))}}static unsafeExposeInternals(e){return{starts:t(e,$),ttls:t(e,U),sizes:t(e,V),keyMap:t(e,m),keyList:t(e,S),valList:t(e,d),next:t(e,R),prev:t(e,x),get head(){return t(e,C)},get tail(){return t(e,E)},free:t(e,B),isBackgroundFetch:i=>{var s;return l(s=e,o,w).call(s,i)},backgroundFetch:(i,s,h,n)=>{var r;return l(r=e,o,wt).call(r,i,s,h,n)},moveToTail:i=>{var s;return l(s=e,o,ft).call(s,i)},indexes:i=>{var s;return l(s=e,o,Q).call(s,i)},rindexes:i=>{var s;return l(s=e,o,tt).call(s,i)},isStale:i=>{var s;return t(s=e,G).call(s,i)}}}get max(){return t(this,N)}get maxSize(){return t(this,L)}get calculatedSize(){return t(this,k)}get size(){return t(this,T)}get fetchMethod(){return t(this,lt)}get dispose(){return t(this,H)}get disposeAfter(){return t(this,P)}getRemainingTTL(e){return t(this,m).has(e)?1/0:0}*entries(){for(const e of l(this,o,Q).call(this))t(this,d)[e]!==void 0&&t(this,S)[e]!==void 0&&!l(this,o,w).call(this,t(this,d)[e])&&(yield[t(this,S)[e],t(this,d)[e]])}*rentries(){for(const e of l(this,o,tt).call(this))t(this,d)[e]!==void 0&&t(this,S)[e]!==void 0&&!l(this,o,w).call(this,t(this,d)[e])&&(yield[t(this,S)[e],t(this,d)[e]])}*keys(){for(const e of l(this,o,Q).call(this)){const i=t(this,S)[e];i!==void 0&&!l(this,o,w).call(this,t(this,d)[e])&&(yield i)}}*rkeys(){for(const e of l(this,o,tt).call(this)){const i=t(this,S)[e];i!==void 0&&!l(this,o,w).call(this,t(this,d)[e])&&(yield i)}}*values(){for(const e of l(this,o,Q).call(this))t(this,d)[e]!==void 0&&!l(this,o,w).call(this,t(this,d)[e])&&(yield t(this,d)[e])}*rvalues(){for(const e of l(this,o,tt).call(this))t(this,d)[e]!==void 0&&!l(this,o,w).call(this,t(this,d)[e])&&(yield t(this,d)[e])}[(Ut=Symbol.iterator,xt=Symbol.toStringTag,Ut)](){return this.entries()}find(e,i={}){for(const s of l(this,o,Q).call(this)){const h=t(this,d)[s],n=l(this,o,w).call(this,h)?h.__staleWhileFetching:h;if(n!==void 0&&e(n,t(this,S)[s],this))return this.get(t(this,S)[s],i)}}forEach(e,i=this){for(const s of l(this,o,Q).call(this)){const h=t(this,d)[s],n=l(this,o,w).call(this,h)?h.__staleWhileFetching:h;n!==void 0&&e.call(i,n,t(this,S)[s],this)}}rforEach(e,i=this){for(const s of l(this,o,tt).call(this)){const h=t(this,d)[s],n=l(this,o,w).call(this,h)?h.__staleWhileFetching:h;n!==void 0&&e.call(i,n,t(this,S)[s],this)}}purgeStale(){let e=!1;for(const i of l(this,o,tt).call(this,{allowStale:!0}))t(this,G).call(this,i)&&(this.delete(t(this,S)[i]),e=!0);return e}info(e){const i=t(this,m).get(e);if(i===void 0)return;const s=t(this,d)[i],h=l(this,o,w).call(this,s)?s.__staleWhileFetching:s;if(h===void 0)return;const n={value:h};if(t(this,U)&&t(this,$)){const r=t(this,U)[i],f=t(this,$)[i];if(r&&f){const u=r-(rt.now()-f);n.ttl=u,n.start=Date.now()}}return t(this,V)&&(n.size=t(this,V)[i]),n}dump(){const e=[];for(const i of l(this,o,Q).call(this,{allowStale:!0})){const s=t(this,S)[i],h=t(this,d)[i],n=l(this,o,w).call(this,h)?h.__staleWhileFetching:h;if(n===void 0||s===void 0)continue;const r={value:n};if(t(this,U)&&t(this,$)){r.ttl=t(this,U)[i];const f=rt.now()-t(this,$)[i];r.start=Math.floor(Date.now()-f)}t(this,V)&&(r.size=t(this,V)[i]),e.unshift([s,r])}return e}load(e){this.clear();for(const[i,s]of e){if(s.start){const h=Date.now()-s.start;s.start=rt.now()-h}this.set(i,s.value,s)}}set(e,i,s={}){var Z,M,Y,A,v;if(i===void 0)return this.delete(e),this;const{ttl:h=this.ttl,start:n,noDisposeOnSet:r=this.noDisposeOnSet,sizeCalculation:f=this.sizeCalculation,status:u}=s;let{noUpdateTTL:F=this.noUpdateTTL}=s;const I=t(this,ut).call(this,e,i,s.size||0,f);if(this.maxEntrySize&&I>this.maxEntrySize)return u&&(u.set="miss",u.maxEntrySizeExceeded=!0),this.delete(e),this;let b=t(this,T)===0?void 0:t(this,m).get(e);if(b===void 0)b=t(this,T)===0?t(this,E):t(this,B).length!==0?t(this,B).pop():t(this,T)===t(this,N)?l(this,o,pt).call(this,!1):t(this,T),t(this,S)[b]=e,t(this,d)[b]=i,t(this,m).set(e,b),t(this,R)[t(this,E)]=b,t(this,x)[b]=t(this,E),c(this,E,b),dt(this,T)._++,t(this,at).call(this,b,I,u),u&&(u.set="add"),F=!1;else{l(this,o,ft).call(this,b);const g=t(this,d)[b];if(i!==g){if(t(this,et)&&l(this,o,w).call(this,g)){g.__abortController.abort(new Error("replaced"));const{__staleWhileFetching:y}=g;y!==void 0&&!r&&(t(this,q)&&((Z=t(this,H))==null||Z.call(this,y,e,"set")),t(this,W)&&((M=t(this,O))==null||M.push([y,e,"set"])))}else r||(t(this,q)&&((Y=t(this,H))==null||Y.call(this,g,e,"set")),t(this,W)&&((A=t(this,O))==null||A.push([g,e,"set"])));if(t(this,ht).call(this,b),t(this,at).call(this,b,I,u),t(this,d)[b]=i,u){u.set="replace";const y=g&&l(this,o,w).call(this,g)?g.__staleWhileFetching:g;y!==void 0&&(u.oldValue=y)}}else u&&(u.set="update")}if(h!==0&&!t(this,U)&&l(this,o,Ft).call(this),t(this,U)&&(F||t(this,ct).call(this,b,h,n),u&&t(this,X).call(this,u,b)),!r&&t(this,W)&&t(this,O)){const g=t(this,O);let y;for(;y=g==null?void 0:g.shift();)(v=t(this,P))==null||v.call(this,...y)}return this}pop(){var e;try{for(;t(this,T);){const i=t(this,d)[t(this,C)];if(l(this,o,pt).call(this,!0),l(this,o,w).call(this,i)){if(i.__staleWhileFetching)return i.__staleWhileFetching}else if(i!==void 0)return i}}finally{if(t(this,W)&&t(this,O)){const i=t(this,O);let s;for(;s=i==null?void 0:i.shift();)(e=t(this,P))==null||e.call(this,...s)}}}has(e,i={}){const{updateAgeOnHas:s=this.updateAgeOnHas,status:h}=i,n=t(this,m).get(e);if(n!==void 0){const r=t(this,d)[n];if(l(this,o,w).call(this,r)&&r.__staleWhileFetching===void 0)return!1;if(t(this,G).call(this,n))h&&(h.has="stale",t(this,X).call(this,h,n));else return s&&t(this,nt).call(this,n),h&&(h.has="hit",t(this,X).call(this,h,n)),!0}else h&&(h.has="miss");return!1}peek(e,i={}){const{allowStale:s=this.allowStale}=i,h=t(this,m).get(e);if(h===void 0||!s&&t(this,G).call(this,h))return;const n=t(this,d)[h];return l(this,o,w).call(this,n)?n.__staleWhileFetching:n}async fetch(e,i={}){const{allowStale:s=this.allowStale,updateAgeOnGet:h=this.updateAgeOnGet,noDeleteOnStaleGet:n=this.noDeleteOnStaleGet,ttl:r=this.ttl,noDisposeOnSet:f=this.noDisposeOnSet,size:u=0,sizeCalculation:F=this.sizeCalculation,noUpdateTTL:I=this.noUpdateTTL,noDeleteOnFetchRejection:b=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection:Z=this.allowStaleOnFetchRejection,ignoreFetchAbort:M=this.ignoreFetchAbort,allowStaleOnFetchAbort:Y=this.allowStaleOnFetchAbort,context:A,forceRefresh:v=!1,status:g,signal:y}=i;if(!t(this,et))return g&&(g.fetch="get"),this.get(e,{allowStale:s,updateAgeOnGet:h,noDeleteOnStaleGet:n,status:g});const D={allowStale:s,updateAgeOnGet:h,noDeleteOnStaleGet:n,ttl:r,noDisposeOnSet:f,size:u,sizeCalculation:F,noUpdateTTL:I,noDeleteOnFetchRejection:b,allowStaleOnFetchRejection:Z,allowStaleOnFetchAbort:Y,ignoreFetchAbort:M,status:g,signal:y};let z=t(this,m).get(e);if(z===void 0){g&&(g.fetch="miss");const j=l(this,o,wt).call(this,e,z,D,A);return j.__returned=j}else{const j=t(this,d)[z];if(l(this,o,w).call(this,j)){const vt=s&&j.__staleWhileFetching!==void 0;return g&&(g.fetch="inflight",vt&&(g.returnedStale=!0)),vt?j.__staleWhileFetching:j.__returned=j}const it=t(this,G).call(this,z);if(!v&&!it)return g&&(g.fetch="hit"),l(this,o,ft).call(this,z),h&&t(this,nt).call(this,z),g&&t(this,X).call(this,g,z),j;const J=l(this,o,wt).call(this,e,z,D,A),zt=J.__staleWhileFetching!==void 0&&s;return g&&(g.fetch=it?"stale":"refresh",zt&&it&&(g.returnedStale=!0)),zt?J.__staleWhileFetching:J.__returned=J}}get(e,i={}){const{allowStale:s=this.allowStale,updateAgeOnGet:h=this.updateAgeOnGet,noDeleteOnStaleGet:n=this.noDeleteOnStaleGet,status:r}=i,f=t(this,m).get(e);if(f!==void 0){const u=t(this,d)[f],F=l(this,o,w).call(this,u);return r&&t(this,X).call(this,r,f),t(this,G).call(this,f)?(r&&(r.get="stale"),F?(r&&s&&u.__staleWhileFetching!==void 0&&(r.returnedStale=!0),s?u.__staleWhileFetching:void 0):(n||this.delete(e),r&&s&&(r.returnedStale=!0),s?u:void 0)):(r&&(r.get="hit"),F?u.__staleWhileFetching:(l(this,o,ft).call(this,f),h&&t(this,nt).call(this,f),u))}else r&&(r.get="miss")}delete(e){var s,h,n,r;let i=!1;if(t(this,T)!==0){const f=t(this,m).get(e);if(f!==void 0)if(i=!0,t(this,T)===1)this.clear();else{t(this,ht).call(this,f);const u=t(this,d)[f];if(l(this,o,w).call(this,u)?u.__abortController.abort(new Error("deleted")):(t(this,q)||t(this,W))&&(t(this,q)&&((s=t(this,H))==null||s.call(this,u,e,"delete")),t(this,W)&&((h=t(this,O))==null||h.push([u,e,"delete"]))),t(this,m).delete(e),t(this,S)[f]=void 0,t(this,d)[f]=void 0,f===t(this,E))c(this,E,t(this,x)[f]);else if(f===t(this,C))c(this,C,t(this,R)[f]);else{const F=t(this,x)[f];t(this,R)[F]=t(this,R)[f];const I=t(this,R)[f];t(this,x)[I]=t(this,x)[f]}dt(this,T)._--,t(this,B).push(f)}}if(t(this,W)&&((n=t(this,O))!=null&&n.length)){const f=t(this,O);let u;for(;u=f==null?void 0:f.shift();)(r=t(this,P))==null||r.call(this,...u)}return i}clear(){var e,i,s;for(const h of l(this,o,tt).call(this,{allowStale:!0})){const n=t(this,d)[h];if(l(this,o,w).call(this,n))n.__abortController.abort(new Error("deleted"));else{const r=t(this,S)[h];t(this,q)&&((e=t(this,H))==null||e.call(this,n,r,"delete")),t(this,W)&&((i=t(this,O))==null||i.push([n,r,"delete"]))}}if(t(this,m).clear(),t(this,d).fill(void 0),t(this,S).fill(void 0),t(this,U)&&t(this,$)&&(t(this,U).fill(0),t(this,$).fill(0)),t(this,V)&&t(this,V).fill(0),c(this,C,0),c(this,E,0),t(this,B).length=0,c(this,k,0),c(this,T,0),t(this,W)&&t(this,O)){const h=t(this,O);let n;for(;n=h==null?void 0:h.shift();)(s=t(this,P))==null||s.call(this,...n)}}};N=new WeakMap,L=new WeakMap,H=new WeakMap,P=new WeakMap,lt=new WeakMap,T=new WeakMap,k=new WeakMap,m=new WeakMap,S=new WeakMap,d=new WeakMap,R=new WeakMap,x=new WeakMap,C=new WeakMap,E=new WeakMap,B=new WeakMap,O=new WeakMap,V=new WeakMap,$=new WeakMap,U=new WeakMap,q=new WeakMap,et=new WeakMap,W=new WeakMap,o=new WeakSet,Ft=function(){const e=new gt(t(this,N)),i=new gt(t(this,N));c(this,U,e),c(this,$,i),c(this,ct,(n,r,f=rt.now())=>{if(i[n]=r!==0?f:0,e[n]=r,r!==0&&this.ttlAutopurge){const u=setTimeout(()=>{t(this,G).call(this,n)&&this.delete(t(this,S)[n])},r+1);u.unref&&u.unref()}}),c(this,nt,n=>{i[n]=e[n]!==0?rt.now():0}),c(this,X,(n,r)=>{if(e[r]){const f=e[r],u=i[r];if(!f||!u)return;n.ttl=f,n.start=u,n.now=s||h();const F=n.now-u;n.remainingTTL=f-F}});let s=0;const h=()=>{const n=rt.now();if(this.ttlResolution>0){s=n;const r=setTimeout(()=>s=0,this.ttlResolution);r.unref&&r.unref()}return n};this.getRemainingTTL=n=>{const r=t(this,m).get(n);if(r===void 0)return 0;const f=e[r],u=i[r];if(!f||!u)return 1/0;const F=(s||h())-u;return f-F},c(this,G,n=>{const r=i[n],f=e[n];return!!f&&!!r&&(s||h())-r>f})},nt=new WeakMap,X=new WeakMap,ct=new WeakMap,G=new WeakMap,jt=function(){const e=new gt(t(this,N));c(this,k,0),c(this,V,e),c(this,ht,i=>{c(this,k,t(this,k)-e[i]),e[i]=0}),c(this,ut,(i,s,h,n)=>{if(l(this,o,w).call(this,s))return 0;if(!K(h))if(n){if(typeof n!="function")throw new TypeError("sizeCalculation must be a function");if(h=n(s,i),!K(h))throw new TypeError("sizeCalculation return invalid (expect positive integer)")}else throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");return h}),c(this,at,(i,s,h)=>{if(e[i]=s,t(this,L)){const n=t(this,L)-e[i];for(;t(this,k)>n;)l(this,o,pt).call(this,!0)}c(this,k,t(this,k)+e[i]),h&&(h.entrySize=s,h.totalCalculatedSize=t(this,k))})},ht=new WeakMap,at=new WeakMap,ut=new WeakMap,Q=function*({allowStale:e=this.allowStale}={}){if(t(this,T))for(let i=t(this,E);!(!l(this,o,Tt).call(this,i)||((e||!t(this,G).call(this,i))&&(yield i),i===t(this,C)));)i=t(this,x)[i]},tt=function*({allowStale:e=this.allowStale}={}){if(t(this,T))for(let i=t(this,C);!(!l(this,o,Tt).call(this,i)||((e||!t(this,G).call(this,i))&&(yield i),i===t(this,E)));)i=t(this,R)[i]},Tt=function(e){return e!==void 0&&t(this,m).get(t(this,S)[e])===e},pt=function(e){var n,r;const i=t(this,C),s=t(this,S)[i],h=t(this,d)[i];return t(this,et)&&l(this,o,w).call(this,h)?h.__abortController.abort(new Error("evicted")):(t(this,q)||t(this,W))&&(t(this,q)&&((n=t(this,H))==null||n.call(this,h,s,"evict")),t(this,W)&&((r=t(this,O))==null||r.push([h,s,"evict"]))),t(this,ht).call(this,i),e&&(t(this,S)[i]=void 0,t(this,d)[i]=void 0,t(this,B).push(i)),t(this,T)===1?(c(this,C,c(this,E,0)),t(this,B).length=0):c(this,C,t(this,R)[i]),t(this,m).delete(s),dt(this,T)._--,i},wt=function(e,i,s,h){const n=i===void 0?void 0:t(this,d)[i];if(l(this,o,w).call(this,n))return n;const r=new _t,{signal:f}=s;f==null||f.addEventListener("abort",()=>r.abort(f.reason),{signal:r.signal});const u={signal:r.signal,options:s,context:h},F=(A,v=!1)=>{const{aborted:g}=r.signal,y=s.ignoreFetchAbort&&A!==void 0;if(s.status&&(g&&!v?(s.status.fetchAborted=!0,s.status.fetchError=r.signal.reason,y&&(s.status.fetchAbortIgnored=!0)):s.status.fetchResolved=!0),g&&!y&&!v)return b(r.signal.reason);const D=M;return t(this,d)[i]===M&&(A===void 0?D.__staleWhileFetching?t(this,d)[i]=D.__staleWhileFetching:this.delete(e):(s.status&&(s.status.fetchUpdated=!0),this.set(e,A,u.options))),A},I=A=>(s.status&&(s.status.fetchRejected=!0,s.status.fetchError=A),b(A)),b=A=>{const{aborted:v}=r.signal,g=v&&s.allowStaleOnFetchAbort,y=g||s.allowStaleOnFetchRejection,D=y||s.noDeleteOnFetchRejection,z=M;if(t(this,d)[i]===M&&(!D||z.__staleWhileFetching===void 0?this.delete(e):g||(t(this,d)[i]=z.__staleWhileFetching)),y)return s.status&&z.__staleWhileFetching!==void 0&&(s.status.returnedStale=!0),z.__staleWhileFetching;if(z.__returned===z)throw A},Z=(A,v)=>{var y;const g=(y=t(this,lt))==null?void 0:y.call(this,e,n,u);g&&g instanceof Promise&&g.then(D=>A(D===void 0?void 0:D),v),r.signal.addEventListener("abort",()=>{(!s.ignoreFetchAbort||s.allowStaleOnFetchAbort)&&(A(void 0),s.allowStaleOnFetchAbort&&(A=D=>F(D,!0)))})};s.status&&(s.status.fetchDispatched=!0);const M=new Promise(Z).then(F,I),Y=Object.assign(M,{__abortController:r,__staleWhileFetching:n,__returned:void 0});return i===void 0?(this.set(e,Y,{...u.options,status:void 0}),i=t(this,m).get(e)):t(this,d)[i]=Y,Y},w=function(e){if(!t(this,et))return!1;const i=e;return!!i&&i instanceof Promise&&i.hasOwnProperty("__staleWhileFetching")&&i.__abortController instanceof _t},Et=function(e,i){t(this,x)[i]=e,t(this,R)[e]=i},ft=function(e){e!==t(this,E)&&(e===t(this,C)?c(this,C,t(this,R)[e]):l(this,o,Et).call(this,t(this,x)[e],t(this,R)[e]),l(this,o,Et).call(this,t(this,E),e),c(this,E,e))};let bt=Ot;const Wt={shape:"shape",logo:"logo"},Dt=async a=>{try{return(await $fetch.raw(a,{responseType:"text"}))._data}catch(e){console.error("Cache fetch failed",e);return}},St={[Wt.shape]:new bt({ttl:1e3*60*5,max:50,fetchMethod:Dt}),[Wt.logo]:new bt({ttl:1e3*60*5,max:1e3,fetchMethod:Dt})},Bt=a=>St[a].entries(),Vt=async(a,e)=>{let i=St[a].get(e);return i||(i=await St[a].fetch(e),i&&St[a].set(e,i)),i||null},Xt={getAsync:Vt,entries:Bt};export{Wt as C,Xt as c};
